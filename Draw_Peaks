% Script to generate table of qx, qy, qz given a unit cell and out-of-plane orientation
% By Christopher Liman 2012
% Also can get similar information from the GIXD Igor Analysis Routine by R. Joseph Kline under UnitCell/PeakName,UnitCellQz,UnitCellQxy

% Unit cell parameters in angstroms or degrees
a = 15.7; b = 27.5; c = 7.0; alpha = 90; beta = 116.5; gamma = 90;
% Vector normal to substrate in reciprocal Miller indices
outofplane_reciprocalvector = [0;1;0];
% The range of reciprocal Miller indices to iterate
hstar_range = 0:3; kstar_range = 0:9; lstar_range = -2:0;

% Reference: http://www.mse.mtu.edu/casting/my3200/stereo/sg4.html
% Transformation matrix from Miller indices to cartesian coordinates [x;y;z]=M[h;k;l]
% c-axis is parallel to z-axis, bstar-axis is parallel to y-axis (arbitrary choice)
% So lattice vectors in cartesian coordinates are a=M(:,1), b=M(:,2), c=M(:,3)
M = [a*sind(beta) b*sind(alpha)*cosd(gamma) 0;
	0 b*sind(alpha)*sind(gamma) 0;
	a*cosd(beta) b*cosd(alpha) c];

% Volume of unit cell in angstroms^3
v = det(M);

% Transformation matrix from reciprocal Miller indices to cartesian coordinates in reciprocal space [xstar;ystar;zstar]=Mstar[hstar;kstar;lstar]
% So reciprocal lattice vectors in cartesian coordinates are astar=Mstar(:,1), bstar=Mstar(:,2), cstar=Mstar(:,3)
Mstar = 2*pi*(M^-1)';

% Rotate reciprocal cartesian coordinate system so that outofplane_reciprocalvector is parallel to [0;0;1] (cartesian coordinates in reciprocal space)
% Then the coordinate system will be [qx;qy;qz] where qz is out of plane (orientation of qx and qy axes are arbitrary)
outofplane_reciprocalvector = Mstar*outofplane_reciprocalvector;
rot_axis = cross(outofplane_reciprocalvector,[0;0;1])/norm(cross(outofplane_reciprocalvector,[0;0;1]));
rot_angle = acos(dot(outofplane_reciprocalvector,[0;0;1])/(norm(outofplane_reciprocalvector)));
% Reference: http://en.wikipedia.org/wiki/Rotation_matrix (Rotation matrix from axis and angle)
R = eye(3)*cos(rot_angle) + sin(rot_angle)*[0 -rot_axis(3) rot_axis(2);
	rot_axis(3) 0 -rot_axis(1);
	-rot_axis(2) rot_axis(1) 0] + (1-cos(rot_angle))*rot_axis*rot_axis';

i = 0;
peaklist = zeros(3,length(hstar_range)*length(kstar_range)*length(lstar_range));
for hstar = hstar_range
	for kstar = kstar_range
		for lstar = lstar_range
			i = i + 1;
			% Generate reciprocal Miller indices of each peak
			peaklist(:,i) = [hstar;kstar;lstar];
		end
	end
end

% Each column corresponds to a peak
qvector = R*(Mstar*peaklist);
qxy = sqrt(qvector(1,:).^2 + qvector(2,:).^2);
q = sqrt(qvector(1,:).^2 + qvector(2,:).^2 + qvector(3,:).^2);
d = 2*pi./q;
% Each row corresponds to a peak
output = [peaklist' qvector' qxy' q' d'];
